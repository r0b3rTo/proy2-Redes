/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "proyecto.h"
#include "centro.h"

Servidor servidor;
HistorialTicket tickets;

int *
obtener_tiempo_respuesta_1_svc(void *argp, struct svc_req *rqstp)
{
	static int  result;
	result = servidor.tiempo;

	return &result;
}

int *
solicitar_envio_gasolina_1_svc(char **argp, struct svc_req *rqstp)
{
   static int  result;
   HistorialTicket ticketBomba;
   int diferencialTiempo = 0;
   
   char* ip = (char*)malloc(sizeof(char)*100);
   if(ip == NULL){
      terminar("Error de asignacion de memoria: " );
   }
   
   char* nombreArchivoLog = (char*)obtenerNombreArchivoLog(servidor.nombreCentro);
   
   strcpy(ip,inet_ntoa(rqstp->rq_xprt->xp_raddr.sin_addr));
   
   ticketBomba = buscarTicket(tickets,ip);
   if((ticketBomba != NULL) || (ticketBomba->tiempoValidacion !=-1)){
      diferencialTiempo = servidor.tiempoSimulacion - ticketBomba->tiempoValidacion;
      printf("\nTiempo simulacion: %d\n",servidor.tiempoSimulacion);
      printf("\ntiempo ticket: %d\n",ticketBomba->tiempoValidacion);
      printf("\nDiferencial de tiempo simulacion vs tiempo ticket:%d\n",diferencialTiempo);
      if(diferencialTiempo<=30){
         if(servidor.inventario >= 38000){
            printf("\nSuministro Ok\n");
            result = 1;
            servidor.inventario = servidor.inventario - 38000;
            escribirArchivoLog(nombreArchivoLog, "Verificacion de Estado del Ticket", 
                              servidor.tiempoSimulacion,servidor.inventario, *argp, "Valido");
            escribirArchivoLog(nombreArchivoLog, "Suministro", servidor.tiempoSimulacion,
                              servidor.inventario, *argp, "Ok");
         }else{
            printf("\nSuministro No Disponible\n");
            result = 0;
            escribirArchivoLog(nombreArchivoLog, "Suministro", servidor.tiempoSimulacion, 
                              servidor.inventario, *argp, "No Disponible");
         }
      }else{
         //escribirArchivoLog
         escribirArchivoLog(nombreArchivoLog, "Verificacion de Estado del Ticket",
                            servidor.tiempoSimulacion,servidor.inventario, *argp, "Vencido");
         result = 2;
      }
   }else{
      //escribirArchivoLog
      escribirArchivoLog(nombreArchivoLog, "Verificacion de Estado del Ticket",
                       servidor.tiempoSimulacion,servidor.inventario, *argp, "Inexistente");
      result = 2;
   }
 
//    if(servidor.inventario >= 38000){
//       ticketBomba = buscarTicket(tickets,ip);
//       if(ticketBomba != NULL){
//          diferencialTiempo = servidor.tiempoSimulacion - ticketBomba->tiempoValidacion;
//          printf("\nTiempo simulacion: %d\n",servidor.tiempoSimulacion);
//          printf("\ntiempo ticket: %d\n",ticketBomba->tiempoValidacion);
//          printf("\nDiferencial de tiempo simulacion vs tiempo ticket:%d\n",diferencialTiempo);
//          if((ticketBomba->tiempoValidacion !=-1) && (diferencialTiempo<=30)){
//             printf("\nSuministro Ok\n");
//             result = 1;
//             servidor.inventario = servidor.inventario - 38000;
//             escribirArchivoLog(nombreArchivoLog, "EstadoTicket", servidor.tiempoSimulacion,
//                               servidor.inventario, *argp, "Valido");
//             escribirArchivoLog(nombreArchivoLog, "Suministro", servidor.tiempoSimulacion,
//                                servidor.inventario, *argp, "Ok");
//          }else{
//             escribirArchivoLog
//             escribirArchivoLog(nombreArchivoLog, "EstadoTicket", servidor.tiempoSimulacion,
//                               servidor.inventario, *argp, "Vencido");
//             result = 2;
//          }
//       }else{
//          escribirArchivoLog
//          escribirArchivoLog(nombreArchivoLog, "EstadoTicket", servidor.tiempoSimulacion,
//                            servidor.inventario, *argp, "Inexistente");
//          result = 2;
//       }
//    }else{
//       printf("\nSuministro No Disponible\n");
//       result = 0;
//       escribirArchivoLog(nombreArchivoLog, "Suministro", servidor.tiempoSimulacion, 
//                         servidor.inventario, *argp, "No Disponible");
//    }

   return &result;
}

int *
solicitar_reto_1_svc(char **argp, struct svc_req *rqstp)
{
   static int  result;
   
   pid_t hijoId;
   int status;
   
   char bufferLectura[256];
   char* parametro = "-s";
   
   char* tokenIgnorado = (char*)malloc(sizeof(char)*100);
   if(tokenIgnorado == NULL){
      terminar("Error de asignacion de memoria: " );
   }
   
   char* claveMD5 = (char*)malloc(sizeof(char)*100);
   if(claveMD5 == NULL){
      terminar("Error de asignacion de memoria: " );
   }
   
   char* parametroMD5 = (char*)malloc(sizeof(char)*100);
   if(parametroMD5 == NULL){
      terminar("Error de asignacion de memoria: " );
   }
   
   char* nombreArchivoLog = (char*)obtenerNombreArchivoLog(servidor.nombreCentro);
   
   char* reto = (char*)malloc(sizeof(char)*100);
   if(reto == NULL){
      terminar("Error de asignacion de memoria: " );
   }
   
   char* ip = (char*)malloc(sizeof(char)*100);
   if(ip == NULL){
      terminar("Error de asignacion de memoria: " );
   }
   
   int pipeMD5[2];
   if((pipe(pipeMD5)) < 0){
      errorFatal("Error: Creaci贸n de pipe para MD5 en solicitud de reto\n");
   }
   
   srand(time(NULL));
   result = rand();
   
   sprintf(reto,"%d",result);
   
   strcpy(ip,inet_ntoa(rqstp->rq_xprt->xp_raddr.sin_addr));
   
   strcpy(parametroMD5,parametro);
   strcat(parametroMD5,reto);
   
   if((hijoId = fork()) < 0){
      errorFatal("Error: Fork para MD5 en solicitud de reto\n");
   }
      
   if(hijoId == 0){
      close(1);
      close(pipeMD5[0]);
      if(dup(pipeMD5[1]) < 0){
         errorFatal("Error: dup en solicitud de reto\n" );
      }
      
      if(execlp("md5","md5", parametroMD5, NULL)){
         errorFatal("Error: execlp en solicitud de reto\n" );
      }
       
      exit(0);
   }
      
   if(hijoId > 0){
      wait(&status);
      close(pipeMD5[1]);
      read(pipeMD5[0],bufferLectura,sizeof(bufferLectura));
      tokenIgnorado = strtok(bufferLectura,"=");
      claveMD5 = strtok(NULL,"=");
      printf("Clave: %s\n", claveMD5);
   }
   
   tickets = insertarTicket(tickets, *argp, ip, claveMD5, -1);
   //escribirArchivoLog		CASO Se incluye un nuevo ticket
   escribirArchivoLog(nombreArchivoLog, "Nuevo Ticket", servidor.tiempoSimulacion,
                     servidor.inventario, *argp, "Agregado");

   return &result;
}

int *
evaluar_respuesta_1_svc(char **argp, struct svc_req *rqstp)
{
   static int  result;
   
   char* ip = (char*)malloc(sizeof(char)*100);
   if(ip == NULL){
      terminar("Error de asignacion de memoria: " );
   }
   
   char* nombreArchivoLog = (char*)obtenerNombreArchivoLog(servidor.nombreCentro);
   
   strcpy(ip,inet_ntoa(rqstp->rq_xprt->xp_raddr.sin_addr));
   
   printf("\nBuscando Ticket...\n");  
   HistorialTicket ticketBomba = buscarTicket(tickets, ip);
   printf("\nTicket Nombre Bomba...%s\n",ticketBomba->nombreBomba);
   printf("\nTicket clave MD5...%s\n",ticketBomba->claveMD5);
   printf("\nArgp...%s\n",*argp);
   
   
   if(ticketBomba != NULL){
      printf("\nTicket encontrado...\n"); 
      //Verificaci贸n de correspondencia de claves
      if(strcmp(ticketBomba->claveMD5,*argp) == 0){
         //escribirArchivoLog		CASO Autenticaci贸n exitosa
         escribirArchivoLog(nombreArchivoLog, "Autenticacion", servidor.tiempoSimulacion,
                           servidor.inventario, ip, "Exitosa");
         printf("\nAutenticacion valida...\n"); 
         ticketBomba->tiempoValidacion = servidor.tiempoSimulacion;
         result = 1;
      }else{
         printf("\nAutenticacion fallida...\n"); 
         //escribirArchivoLog		CASO Autenticaci贸n fallida
         escribirArchivoLog(nombreArchivoLog, "Autenticacion", servidor.tiempoSimulacion,
                           servidor.inventario, ip, "Fallida");
         result = 0;
      }
   }else{
      mensajeError("Error: La Bomba no ha solicitado reto anteriormente\n");
      result = 0;
   }

   return &result;
}
